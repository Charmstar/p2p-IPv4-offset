
Libpcap captures discernible SYNs that encode and transfer an encrypted text file two bytes at a time in successive SYN-only TCP Checksums, before the
receiver's Linux kernel evaluates and discards invalid TCP packets, similar to Wireshark, assuming TCP Offload is disabled on sender's Ethernet port.  
Continuous SYNs resemble a SYN flood attack that unaffected censors presumably track as laissez-faire and do not expend engineering effort to block.

Invalid TCP Checksum protocol encodes an encrypted text file two bytes at a time in successive, discernible SYN-only TCP Checksums. A point-to-point 
receiver accumulates received discernible SYN TCP Checksums, adjusted for any OFFSET due to NAT(s), into a file (translatedbinaryout) two bytes at a time,
then uses gpg -d to decrypt that file.
 
One way to make SYNs discernible by mutual agreement is to use a libpcap capture filter for SYN destination port 22 with source port 20. 

              "tcp[tcp-flags] & tcp-syn !=0 && tcp[tcp-flags] & tcp-ack ==0 && dst port 22 && src port 20" 
        
Above is an example capture filter SYN port combination that will not likely encounter false positives from another source's SYN.

Sender's nsendit.py must know the far-end's IPv4 address and uses Python scapy sr1() to test if that far-end IPv4 address is awake, but first starts 
the receive1.c program to capture the sr1()'s valid TCP Checksum on the way out, using ntohs() to correct back to little-endian order from the network
order that scapy sends. This defines both the sender's ESCAPE packet and the receiver's ESCAPE packet. 

>>>p=IP(dst=IPv4addr)/TCP(dport=22, sport=20)
>>>sr1(p)
>>>p=IP(dst=IPv4addr)/TCP(dport=22, sport=20, chksum=0xffff)
>>>send(p)
>>>p=IP(dst=IPv4addr)/TCP(dport=22, sport=20, chksum=0x0)
>>>send(p)
>>>p=IP(dst=IPv4addr)/TCP(dport=22, sport=20)
>>>send(p)

The receiver.c program evaluates the above preamble when received. If the second and third TCP Checksums are the same value then there are one or more NATs
in the point-to-point IP path, conveniently this same value is defined as OFFSET. All subsequent TCP Checksums received will subtract OFFSET modulo 0x10000
to get back to the intended value before storing in the translatedbinaryout file.

Invalid TCP Checksum protocol encodes an encrypted text file two bytes at a time: when those two bytes are ffff then nsendit.py first sends a sender's ESCAPE
packet, then sends a SYN with invalid TCP Checksum 0xffff and receiver interprets both packets together as only one packet 0xffff, even if the second packet
is received as 0x0. A lone 0x0 or 0xffff received is interpreted as 0x0. When the two bytes of the sender's ESCAPE hex value need to be sent, then the ESCAPE
packet is sent twice and receiver interprets two ESCAPE packets in succession as one. 

On a LAN, or point-to-point between two VPS Public IP addresses, there is no OFFSET (i.e. OFFSET=0x0), yet receiver's accumulated file is still gpg -d 
decryptable.   Not all NATs will port forward an invalid TCP Checksum SYN packet, but there are some home wireless routers that do.  Invalid TCP Checksum
protocol discovers a non-zero OFFSET that is applied to each received discernible TCP Checksum, then stored in the translatedbinaryout file.

Invalid TCP Checksum protocol is intended for binary mode encrypted text file transfer between little-endian end-points, preferably only using even length 
files (as per ls -l), to avoid bogus gpg decryption errors reported on odd length files.  

Preparations for Linux CentOS 7 :
yum install update
yum install python3
yum install epel-release
yum install python-pip
pip3 install scapy
yum install wireshark
yum install libpcap-devel
yum install gcc

In root's .bash_profile disable TCP Offload on sender:
ethtool --offload enp0s25 rx off tx off 

