
Libpcap captures discernible SYNs that encode and transfer an encrypted file two bytes at a time in successive, SYN-only TCP Checksums, before the
receiver's Linux kernel evaluates and discards invalid TCP packets, assuming TCP Offload is disabled on sender's Ethernet port.  Continuous, successive 
SYNs resemble a SYN flood attack that unaffected censors presumably track as laissez-faire and do not expend engineering effort to block.

A discernible SYN receiver determines a two byte OFFSET after receiving five specially Python scapy crafted and discernible "Invalid TCP Checksum 
protocol" SYNs.  The receiver then returns five discernible SYNs back to the sender. One way to make SYNs discernible by mutual agreement is to use a 
libpcap capture filter for SYN destination port 22 with source port 20. 

              "tcp[tcp-flags] & tcp-syn !=0 && tcp[tcp-flags] & tcp-ack ==0 && dst port 22 && src port 20" 
        
Above is an example capture filter SYN port combination that will not likely encounter false positives from another source's SYN.

To begin "Invalid TCP Checksum protocol", a sender initiates a discernible, valid TCP Checksum SYN to an IPv4 address using Python's scapy and waits 
for SYN-ACK. Sender next sends a second valid TCP Checksum SYN followed by three scapy discernible SYNs with TCP Checksums 0xffff, 0x0, and 0xff00.

>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20)
>>>sr1(p)
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20)
>>>send(p)
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20, chksum=0xffff)
>>>send(p)
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20, chksum=0x0)
>>>send(p)
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20, chksum=0xff00)   
>>>send(p)

Receiver's discernible ESCAPE SYN packet is defined as the actual TCP Checksum hex value of the second discernible SYN packet received. Receiver's 
OFFSET is defined as the actual TCP Checksum hex value received in the fourth discernible SYN pakcet received. The receiver derives the sender's 
original ESCAPE hex value (ESCAPE-OFFSET modulo 0x10000) and sends five discernible SYNs back to the sender. 

>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20)
>>>send(p)
>>>send(p) 
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20, chksum=0xffff)
>>>send(p)
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20, chksum=0x0)
>>>send(p)
>>>p=IP(dst="IPv4addr")/TCP(dport=22, sport=20, chksum=(ESCAPE-OFFSET mod 0x1000))
>>>send(p)

Sender derives sender's own original ESCAPE TCP Checksum hex value by subtracting the fifth discernible SYN's TCP Checksum from the fourth discernible SYN's
TCP Checksum, without having to calculate a TCP Checksum!

When sender later intends to encode 0xffff from an encrypted file into a discernible SYN TCP Checksum it is preceded by a discernible ESCAPE SYN and the 
receiver interprets the two received SYN packets as a single 0xffff, even if the second SYN packet is received as 0x0.  Two discernible ESCAPE SYN packets 
are sent to encode two bytes of a single valid TCP Checksum. When there is no OFFSET, then a received lone 0x0 is always interpreted as 0x0. Otherwise, an 
OFFSET is indicated by the second and third received discernible SYNs. Subsequent SYN TCP Checksums minus OFFSET modulo 0x10000 reveal the sender's 
intended two bytes per packet hex encoding that receiver successively accumulates to a gpg decryptible file that confirms error free transmission.

Once the respective ESCAPE SYN TCP Checksum hex values are derived for sender and receiver, consecutive invalid SYN TCP Checksums (possibly peppered with 
an occasional valid TCP Checksum ESCAPE packet) transfer an encrypted file from sender to receiver, two bytes at a time, captured by a discernible libpcap
at the receiver. Not all NATs will port forward an invalid TCP Checksum, but there are some home wireless routers that do. When there is no end-to-end NAT
translation (e.g. on a LAN) SYN ESCAPE packets are not needed but ESCAPE packets are not accumulated, so won't interfere with encrypted file transfers.

Invalid TCP Checksum protocol is intended for binary mode encrypted text file transfers between little-endian end-points. Binary mode encrypted binary
file transfer is also possible between Linux end-points, Mac end-points require special instructions to byte-swap decrypted binary files.

